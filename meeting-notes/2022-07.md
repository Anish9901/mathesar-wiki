---
title: July 2022 meeting notes
description: 
published: true
date: 2022-07-22T14:42:14.522Z
tags: 
editor: markdown
dateCreated: 2022-07-20T15:18:53.284Z
---

# 2022-07-22 dependencies meeting

**Topic**: Decide scope of Yurii's dependency project in the product and UI design
**Attendees**: Kriti, Brent, Mukesh, Ghislaine

Two types of dependencies:
- DB objects (tables, functions, etc.)
- Mathesar objects

We need to portray `CASCADE` deletes (no-max-depth deletion of dependencies) differently from deleting Mathesar objects.

## Brainstorming about dependencies in the UI

### Brent's wish-list
- Show "what would be deleted"
- Be able to use our own dependency tree to do the cascade delete, so that we don't end up deleting dependencies not shown on the UI
- User should understand the difference between data deletions and data view or structure deletions
- User should understand delinking deletions
- UI should be able to handle arbitrary depth
- Categorize different dependencies.
    - data vs. representation
    - schemata
    - tables
    - constraints
    - functions
    - indexes
    - columns (maybe we could just drop fkey columns pointing to a table we want to delete)
    - sequences owned by table
    - etc.
- Dependencies of every type of object that can be directly deleted through Mathesar should be visible (even if we don't have mathesar models for dependent objects)

### Kriti's wish-list
- We should track dependencies that are types of objects not handled by Mathesar's UI (functions, indexes, whatever)
- We should show object types that we do have in the UI in as much detail as possible
- We should tell users when there are dependencies on object types that we don't show in the UI (functions, etc.) and list them if we can
- We should also let the user know about non-DB object dependencies:
    - e.g. Mathesar queries, record summary templates
- We need to handle issues with objects that the user doesn't have permissions for

### Mukesh's wish-list
- We should be using Django objects in place of database identifier
- Other dependencies should just contain the name(best case)
- dependencies should be categorized
- Filters for getting only certain objects

### Ghislaine's Wish-List
- Balance between risk of losing data and user inconvenience. We should avoid having the user take extra steps for minimal risk actions like columns, or summaries
- We need to handle bulk deletion scenarios. A user deleting multiple tables. Would we delete in steps and show dependencies for each? or a full list for all?
- Assuming that a constraint is deleted, user should be made aware of this when opening the table, not just at moment of deletion
    - Something like "information about table changes" when opening the table
    - Could this need a way to relink the column with all the FK?

## Scope of the GSoC project
- UI scope should be limited to using dependencies during deletion and related operations, we will not have any other UI that uses dependencies.
- Brent, Yurii, and Mukesh will meet to discuss possible merging of dependencies and table relationships
- The scope will include tracking dependencies of all objects that the Mathesar API handles, i.e.
    - DBs
    - Schemas
    - Tables
    - Columns
    - Constraints
- The dependents tracked will include ALL objects, even if they're not handled by the Mathesar API

### Not in scope
- Separate page to show entire schema / DB depdendency graph
- Tracking dependencies of records
- Viewing the dependency graph of a single object without triggering a deletion

### Type of deletion
- For the best UX, we should allow the users to delete multiple objects at once. It's annoying when projects only allow deletion of one object at once.
- We do need to support automatic deletions of dependent objects as long as we have clarity on what's getting deleted
    - If we don't have clarity, we should make that very very clear.

### Priorities for the GSoC project
- Backend parity with Postgres dependency tracking (so that we don't have to resort to `CASCADE`)
- Backend for tracking Mathesar objects:
    - mapping tables and reverse dependencies
    - queries
    - record summaries
    - etc.

We can ship the project in a few different milestones.

**Milestone 1:** We show all the DB-only dependencies we can in the UI, allow users to use `CASCADE` if possible. 

**Milestone 2:** We track mapping tables and reverse dependencies and show them in the UI

**Milestone 3:** We track Mathesar dependencies that are only in the service DB and show them in the UI (queries, record summaries)

**Milestone 4:** We track dependent DB functions (things not tracked in `pg_depends`)

**Milestone 5:** Parity with Postgres dependency tracking so that we can stop using `CASCADE`

# 2022-07-20 weekly meeting

## Embedded Queries vs Parameterized Queries
- **Summary**: Figure out where the feature boundary between embedded and parameterized queries is and what's actually essential for Cycle 3.
- **Participants:**: Kriti, Sean, Ghislaine, Pavish, Brent, Mukesh, Dhruvi

We're all in agreement about the Record Page, which is a page that shows an individual record's details. There's a section in the page that shows a summary of related records and can allow records shown to be filtered.

The goal of this meeting is to figure out how much of this to implement in Cycle 3, since we have a lot of work to do and we want to do the minimum necessary to get the demo use case working. 

### Product and design concerns
[Record Page](https://wiki.mathesar.org/en/design/specs/record-page) design spec so far.

The product goal of embedded queries is to show a summary of related records on a record page. The data shown
should match the links available via Data Explorer UI for consistency.

### Sean's long-term goals for the record page UX
- Let's work from the Patrons record page as an example.
- A section of the Patrons record page displays related records which link to the patron.
- That section contains a list of queries.
- There are two types of queries within the list -- "auto-generated queries" and "manually-generated queries".
- Both types of queries can be re-ordered within the list
- Auto-generated queries:
    - display a table of the related records with all columns.
    - show on the record page by default according to the schema and thus will auto-update when the schema changes
    - should meet user's needs in a majority of circumstances
    - can be hidden via an icon button (and un-hidden via a dropdown menu higher up on the page)
- Manually-generated queries
    - Can be renamed
    - Can be edited
    - Can be deleted
    - Can be created from scratch using the data explorer
- Reactions:
    - Other team members seem mostly in agreement with this UX vision
    - Kriti would like a way to eventually display the related records in a list form (e.g. genres associated with a book). But we'll consider that use-case later.
    - We may eventually want to design functionality for the user to add new related records from within the record page. For example, I may want to record a new checkout for a patron directly on the patron's page. We'll consider that use-case later.

### Backend concerns
- Need to be able to add/remove initial columns according to user desire from a stored query
- Don't really need parameterized queries for the embedded queries. We can filter for the desired id using query string parameters when actually calling the query.
- Links to record:
    - call table endpoint, using filter for appropriate ID

### Decisions
- We recognized that for our needs on the record page, we can handle the "parameterization" of queries using the "filters" functionality that we already have.
- The "auto-generated queries" on the record page will be displayed using our basic records API. No need to create a query resource at all! Just fetch the records and apply a filter to the FK column.
- For cycle 3 we'll only focus on "auto-generated queries". The "manually-generated queries" functionality will be designed/implemented later.
- The output of the auto-generated queries can be further filtered, beyond the auto-added FK filter condition. Any additional filter conditions that the user adds will not persist. But this ad-hoc filtering functionality also gets us a bit closer to the final goal of displaying checked-out books on the Patrons record page -- all without using the data explorer (or Mathesar "queries") at all!

### Next steps
- The "Embedded Queries" feature is now folded into the "Record Page" feature. Because we're not actually using "queries" for the functionality, we may use a name like "Table Widgets" (or similar) to refer to this functionality going forward.
- The "Parameterized Queries" feature is removed entirely as it seems like we may never need it. When the time comes for us to implement "manually-generated queries", we will likely create basic query objects and then filter their results using the filtering functionality when displaying the query (_not_ by altering the query definition).
- Brent is assigned to the Record Page backend since it doesn't involve the Data Explorer anymore. The only thing we need to do is to make the "joinable tables" API work in both directions.
- Kriti will update the storyboard to remove the two features and update the flow according to the new implementation we decided on

# 2022-07-19 Cycle 3 planning
- **Participants:**: Kriti, Sean, Ghislaine, Pavish, Brent, Mukesh, Dominykas, Rajat, Dhruvi

We discussed the [Cycle 3 storyboard](https://www.figma.com/file/F0FmNaNz8hvrgxPax3Bix1/Cycle-3-reference?node-id=2%3A103), prioritized features, and assigned work to various team members. There were questions raised about the features "Embedded Queries" and "Parameterized Queries", which we are going to schedule a separate meeting to iron out.

Team members who are working on Cycle 3 can view the [work assignment spreadsheet here](https://docs.google.com/spreadsheets/d/1IqW3GiwYibvS3gleIKHhTa51WF_coOg2BqJA5ffPtVI/edit#gid=0).

# 2022-07-18 Cycle 2 retrospective
- **Participants:**: Kriti, Sean, Ghislaine, Pavish, Brent, Mukesh, Dominykas

We discussed what went well and what could have gone better in Cycle 2, plus ideas for how to improve our workflow in Cycle 3. We used a whiteboarding tool during the meeting and did not take additional notes since the meeting focused on team workflow.

Core team members can view the [whiteboard here](https://www.figma.com/file/8MzwZLSRbyQKDi8I2mnnbW/Cycle-2-retrospective?node-id=0%3A1).
